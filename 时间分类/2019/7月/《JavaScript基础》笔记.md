# 《VUE》笔记

###### author:朱泽聪
###### createTime:2019/7/8
###### 课程目标,能理解JS跟ES之间的联系,明白闭包是什么,清楚如何确定JS中this指针的指向，清楚JS表达式和语句的区别。

## 目录

* [JS与ES](#1,JS与ES)
* [表达式与语句](#2,表达式与语句)
* [作用域与闭包](#3,作用域与闭包)
* [JS中的this](#4,JS中的this)

## 1,JS与ES

**规范发布新流程:**[https://tc39.es/process-documnet](https://tc39.es/process-documnet)

**TC39新特性仓库:**[https://github.com/tc39/proposals](https://github.com/tc39/proposals)

### JS与ES的区别

* ES是JS的官方规范,ES定义了JS的核心,包括基本语法,内置对象,内置函数等。
* JS是ES的实现,并且不同的JS平台往往会添加一些不属于ES的自有实现。

## 2,表达式与语句

**表达式的定义:** 表达式是JS中的短语,引擎会对表达式计算一个返回值,所以通常表达式的主要目的是计算值。

**语句的定义:** 语句是JS中完整的句子或命令,语句总是以分号结束,语句的目的就是用来产生某种副作用。

## 3,作用域与闭包

### 3.1 词法作用域和动态作用域

**词法作用域:** 定义在词法阶段的作用域,函数和变量的作用域由书写代码时,函数和变量的声明位置决定。

**动态作用域:** 基于调用栈的作用域,在代码runtime的时候才决定,灵活多变,但是无法提前准确预知。

**JS作用域:** 词法作用域

### 3.2 var与函数作用域, let const与块作用域

**var声明的特性:** 函数作用域, 变量提升, 浏览器全局中声明会添加到window对象。

**let, const声明的特性:** 块作用域, 无变量提升+暂时性死区, 在for循环中绑定每一个迭代。

``` js
// 暂时性死区: 变量声明之前无法被调用
{
    console.log(a)
    let a = 1;
}
// 运行结果: ReferenceError: a is not defined
```

### 3.3 闭包定义, 优势和劣势

**闭包定义:** 当一个变量"脱离"了声明所处的作用域而存在时, 这个变量就成了闭包。

**闭包优势:** 延长变量的生命周期, 让函数可以保存状态, 并且对外隐藏状态。

**闭包劣势:** 变量无法释放, 引发内存泄漏, 需要手动释放变量。

## 4,JS中的this

**实际开发中的this判断原则:**

* 浏览器中全局this指向window对象。
* 如果是ES6中的箭头函数, 则继承外层的this指针。
* new关键字调用, 则this指向新建对象。
* 如果函数使用了bind, apply, call进行调用, 则this指向显示绑定的对象。
* 函数是否作为某个对象订单方法进行调用。
* 独立函数调用, 严格模式下this指向undefined, 否则指向全局对象。

``` js
// 箭头函数
let obj = {
    printThis1 : () => {
        console.log(this)
    },
    printThis2 : function(){
        console.log(this)
    }
}

obj.printThis1()    // 输出: window:{...}
obj.printThis2()    // 输出: obj:{...}
```
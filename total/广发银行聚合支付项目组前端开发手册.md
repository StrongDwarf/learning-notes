# 广发银行聚合支付项目组前端开发手册

## 目录

* [编程规约](#编程规约)
  * [命名规约](#命名规约)
  * [常量定义](#常量定义)
  * [格式规约](#格式规约)
  * [控制语句](#控制语句)
  * [注释规约](#注释规约)
  * [其他](#其他)
* [编程实践]
  * [HTML编程实践](#HTML编程实践)
  * [CSS编程实践](#CSS编程实践)
  * [js编程实践](#js编程实践)
  * [VUE编程实践](#VUE编程实践)
* [程序设计优化实践](#程序设计优化实践)

## 编程规约

### 命名规约

#### 1,代码中的命名均不能以下划线或美元符号开始,也不能以下划线或美元符号结束

``` js
// 反例
_name / __name / $Object / name_ / name$ / Object$ /
```

#### 2,代码中的命名严禁使用拼音与英文混合的方式,更不允许直接使用中文的方式。

说明: 正确的英文拼写和语法可以让阅读者易于理解,避免歧义。注意,即使纯拼音命名方式也要避免采用

``` js
// 反例
DaZhePromotion [打折] / getPintfenByName() [评分] / int 某变量 = 3
// 正例
alibaba / taobao / youku / hangzhou 等国际通用的名称，可视为英文。
```

#### 3,类名使用UpperCamelCase风格,必须遵从驼峰形式

``` js
// 正例
/**
 * 用户工具类:保存用户相关公共操作
 **/
class UserTool {
    // ...
}
```

#### 4,方法名,参数名,成员变量,局部变量都统一使用lowerCamelCase风格,必须遵从驼峰形式

``` js
// 正例
localValue / getHttpMessage() / inputUserId
```

#### 5,常量命名全部大写,单词间用下划线隔开,力求语义表达清楚,不要嫌名字长

``` js
// 正例
MAX_STOCK_COUNT
// 反例
MAX_COUNT
```

### 常量定义

#### 1,不允许出现任何魔法值(即未定义的常量)直接出现在代码中

``` js
// 反例
let key = "ID#taobao_" + tradeId
```

#### 2,使用对象维护常量,而不是直接在代码中使用常量

``` js
// 反例
let getUsers = function() {
    Ajax.post("http://localhost:8080/User/getUserDetail", {}, data => {
        if(!data.success) {
            alert('接口调用出错')
        }
        // ...
    })
}
```

``` js
// 正例

// apiUrl单例
const apiUrl = (function(){
    let host = "http://localhost:8080"
    return {
        // user相关接口
        user:{
            getUserDetail:`${host}/User/getUserDetail`
        }
    }
})()

// 错误提示单例
const errorPrompt = {
    AJAX_CALL_ERROR:'接口调用出错',
}

// 获取用户信息函数
let getUsers = function() {
    Ajax.post(apiUrl.user.getUserDetail, {}, data => {
        if(!data.success) {
            alert(errorPrompt.AJAX_CALL_ERROR)
        }
        // ...
    })
}
```

#### 3,前端常量复用层次有4层:应用内共享常量,单页面中共享常量,组件中共享常量,函数内共享常量

##### 1) 应用内共享常量

应用内共享常量在store中定义,并使用AppConstants对象进行管理,且需在getters中为其提供对外接口,在实际编程中只能通过this.$store.getters.constantName方式访问,而不能使用this.$store.state.constantName的方式访问。

``` js
// 正例

// 目录:./store/apiUrl.js
const apiUrl = (function(){
    let host = 'http://localhost:8080'
    return {
        user: {
            login: `${host}/user/login`
        }
    }
})()

module.exports = apiUrl

// 目录:./store/index.js
import Vue from 'vue'
import Vuex from 'vuex'
import apiUrl from './apiUrl.js'

const store = new Vuex.Store({
    state:{
        apiUrl,
        AppConstants:{
            SYSTEM_NAME:'聚合支付管理平台'
        }
    },
    getters:{
        apiUrl: state => {
            const apiUrl = state.apiUrl
            return apiUrl
        },
        AppConstants: state => {
            const AppConstants = state.AppConstants
            return AppConstants
        }
    },
})
```

##### 2) 单页面中共享常量:写在该页面的data中

##### 3) 组件中共享常量:同样写在组件的data中

``` js
// 反例
Vue.component('login', {
    template: `
        <div>
            <!-- 省略部分代码 -->
            <el-form ref="form" :model="form" label-width="80px">
                <el-form-item label="编号类型">
                    <el-select v-model="form.type" placeholder="请选择编号类型">
                        <el-option label="面试官" value="1"></el-option>
                        <el-option label="候选人" value="2"></el-option>
                    </el-select>
                </el-form-item>
            </el-form>
            <!-- 省略部分代码 -->
        </div>`,
    data: () => {
        return {
        }
    },
    methods: {
        login() {
            // 省略代码
        }
    },
})
```

``` js
// 正例=
Vue.component('login', {
    template: `
        <div>
            <!-- 省略部分代码 -->
            <el-form ref="form" :model="form" label-width="80px">
                <el-form-item label="pageConstants.label.NUMBER_TYPE">
                    <el-select v-model="form.type" placeholder="pageConstants.placeholder.PLEASE_SELECT_NUMBER_TYPE">
                        <el-option label="pageConstants.label.INTERVIEWER" value="pageConstants.value.INTERVIEWER_TYPE"></el-option>
                        <el-option label="pageCconstants.label.CANDIDATER" value="pageConstants.value.CANDIDATER_TYPE"></el-option>
                    </el-select>
                </el-form-item>
            </el-form>
            <!-- 省略部分代码 -->
        </div>`,
    data: () => {
        return {
            pageConstants: {
                label: {
                    NUMBER_TYPE: '编号类型',
                    INTERVIEWER: '面试官',
                    CANDIDATER: '候选人'
                },
                placeholder: {
                    PLEASE_SELECT_NUMBER_TYPE: '请选择编号类型',
                },
                value: {
                    INTERVIEWER_TYPE: '1',
                    CANDIDATER_TYPE: '2'
                }
            },
        }
    },
    methods: {
        login() {
            // 省略代码
        }
    },
})
```

##### 4) 函数内共享常量

函数内共享常量在函数中定义,并使用funcConstants对象进行管理

### 格式规约

#### 1,大括号的使用约定。如果大括号内为空,则简洁地写成{}即可,不需要换行;如果是非空代码块则:

* 1)左大括号前不换行。
* 2)左大括号后换行。
* 3)右大括号前换行。
* 4)右大括号后还有else等代码则不换行;表示终止右大括号后必须换行。

#### 2,左括号和后一个字符之间不出现空格;同样,右括号和前一个字符之间也不出现空格。详见第5条下方正例提示

#### 3,if/for/while/switch/do等保留字与左右括号之间都必须加空格

#### 4,任何运算符左右必须加一个空格

说明:运算符包括赋值运算符=,逻辑运算符&&,加减乘除符号,三目运算符等。

#### 5,缩进采用4个空格

``` js
// 正例:(涉及1-5点)
function login(number, password) {
    let funConstants = {
        PROMPT_EMPTY_NUMBER: '用户名不能为空',
        PROMPT_EMPTY_PASSWORD: '密码不能为空',
    }
    if(!number && number != '') {
        alert(funConstants.PROMPT_EMPTY_NUMBER)
        return
    }
    if(!password && password != '') {
        alert(funConstants.PROMPT_EMPTY_PASSWORD)
        return
    }
    // 省略代码
}
```

#### 6,单行字符数限制不超过120个,超出需要换行,换行时遵循如下原则:

* 1)第二行相对第一行缩进4个空格,从第三行开始,不再继续缩进,参考示例:
* 2)运算符与下文一起换行。
* 3)方法调用的点符号与下文一起换行。
* 4)在多个参数超长,逗号后进行换行
* 5)在括号前不要换行,见反例

``` js
// 正例
let str = ""
// 超过120个字符的情况下,换行缩进4个空格,并且方法前的点符号一起换行
str.concat("word1").concat("word2")...
    .concat("wordn").concat("wordn+1")
```

``` js
// 反例
str.concat("word1").concat("word2")....concat
    ("wordn").concat("wordn+1")
```

#### 7,方法参数在定义和传入时,多个参数逗号后边必须加空格

``` js
// 正例
method("a", "b", "c")
```

#### 8,没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐

``` js
// 正例
let a = 3,
    b = 4,
    c = 5;
```

#### 9,方法体内的执行语句组,变量的定义语句组,不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行

说明:没有必要插入多行空格进行隔开

### 控制语句

#### 1,在一个switch块内,每个case要么通过break/return等来终止,要么注释说明程序将继续执行到哪一个case为止;在一个switch块内,都必须包含一个default语句并且放在最后,即使它说明代码也没有

#### 2,在if/else/for/while/do语句中必须使用大括号,即使只有一行代码

``` js
// 反例
if (condition) statements
```

#### 3,推荐尽量少用else, if-else的方式可以改写成:

``` js
if (condition) {
    //...
    return obj
}
// 接着写else的业务逻辑代码
```

说明:如果非得使用if()...else if()...else...方法表达逻辑, 请勿超过3层,超过请使用状态设计模式。

正例:逻辑上超过3层的if-else代码可以使用卫语句,或者使用状态模式来实现

#### 4,除常用方法(如getXxx/isXxx)等外,不要在条件判断中执行其他复杂的语句,将复杂逻辑判断的结果赋值给一个有意义的布尔变量名,以提高可读性

说明:很多if语句内的逻辑相当复杂,阅读者需要分析条件表达式的最终结果,才能够明确什么样的条件执行什么样的语句,那么,如果阅读者分析表达式错误呢?

``` js
// 正例
let existed = (file.open(fileName, "w") != null) && (...) || (...)
if (existed) {
    // ...
}
```

``` js
// 反例
if((file.open(fileName, "w") != null) && (...) || (...)) {
    // ...
}
```

#### 5,循环体中的语句要考量性能,以下操作尽量移至循环体外处理,如定义对象,变量。

#### 6,不准使用try...catch...语句

说明:try...catch语句的设计初衷在于捕获有可能会发生的错误,这类错误包括文件读取错误,数据库错误,IO错误等,但值得注意的是前端没有任何错误是不确定是否可能会发生的错误,前端所有使用try...catch语句的地方都可以使用if...else代替

``` js
// 反例
try{
    let state = {
        qrId: path.split("qrId=")[1].split("&")[0],
        hasAmount: path.split("hasAmount=")[1].split("&")[0],
        mercNum: path.split("mercId=")[1].split("&")[0],
        storeId: path.split("storeId=")[1].split("&")[0],
        operatorId: path.split("operatorId=")[1].split("&")[0]
    }
    this.state = JSON.stringify(state)
} catch (e) {
    let state = path.split("state=")[1].split("#")[0]
    state = JSON.parse(decodeURIComponent(state))
    sessionStorage.setItem("qrId", stat.qrId)
    sessionStorage.setItem("hasAmount", state.hasAmount)
    sessionStorage.setItem("mercNum", state.mercNum)
    sessionStorage.setItem("storeId", state.storeId)
    sessionStorage.setItem("operatorId", state.operatorId)
}
```

``` js
// 正例
let strList = ["qrId=", "hasAmount=", "mercId", "storeId=", "operatorId="]
let isAllExited = true
strList.forEach((value, index) => {
    if (path.indexOf(value) === -1) {
        isAllExited = false
    }
})
if (isAllExited) {
    let state = {
        qrId: path.split("qrId=")[1].split("&")[0],
        hasAmount: path.split("hasAmount=")[1].split("&")[0],
        mercNum: path.split("mercId=")[1].split("&")[0],
        storeId: path.split("storeId=")[1].split("&")[0],
        operatorId: path.split("operatorId=")[1].split("&")[0]
    }
    this.state = JSON.stringify(state)
} else {
    let state = path.split("state=")[1].split("#")[0]
    state = JSON.parse(decodeURIComponent(state))
    sessionStorage.setItem("qrId", stat.qrId)
    sessionStorage.setItem("hasAmount", state.hasAmount)
    sessionStorage.setItem("mercNum", state.mercNum)
    sessionStorage.setItem("storeId", state.storeId)
    sessionStorage.setItem("operatorId", state.operatorId)
}
```

### 注释规约

#### 1,方法内部单行注释,在被注释语句上方另起一行,使用//注释。方法内部多行注释使用 /* */ 注释,注意与代码对齐

#### 2,与其"半吊子"英文注释,不如用中文注释把问题说清楚。转有名词与关键字保持英文原文即可。

反例: "TCP连接超时" 解释成 "传输控制协议连接超时",理解反而费脑筋

#### 3,代码修改的同时,注释也要进行相应的修改,尤其是参数,返回值,核心逻辑等的修改

说明:代码与注释更新不同步,就像路网与导航软件更新不同步一样,如果导航软件严重滞后,就失去了导航的意义

#### 4,注释后的代码尽量要配合说明,而不是简单的注释掉

说明:代码被注释掉有两种可能性: 1) 后续会恢复此段代码逻辑。 2) 永久不用。 前端如果没有备注信息,难以知晓注释动机。后者建议直接删掉
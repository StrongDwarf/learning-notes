# 函数组合

## 需求

我们需要写一个函数,输入"小白菜",返回"HELLO,XIAOBAICAI"

## 尝试

``` javascript
var toUpperCase = function(x){return x.toUpperCase()}
var hello = function(x){return 'HELLO ' + x}

var greet = function(x){
    return hello(toUpperCase(x))
}

greet('xiaobaicai')
```

还好我们只有两个步骤,首先小写转大写,然后拼接字符串。如果有更多的操作,greet函数里就需要更多的嵌套，类似fn3(fn2(fn1(fn0(x))))

## 优化

试想我们写个compose函数:

``` JavaScript
var compose = function(f,g){
    return function(x){
        return f(g(x))
    }
}
```

greet函数就可以被优化为:

``` javascript
var greet = compose(hello,toUpperCase)
greet('xiaobaicai')
```

但是现在的compose函数也只是能支持两个参数,如果有更多的步骤呢?我们岂不是要这样做:

``` javascript
compsoe(d,compose(c,compose(b,a)))
```

为什么我们不写一个帅气的compose函数支持传入多个函数呢?这样就变成了:

``` javascript
compose(d,c,b,a)
```

## compose

``` JavaScript
function compose(){
    var args = arguments,
        start = args.length - 1
    return function(){
        var i = start,
            result = args[start].apply(this,arguments)
        while(i--) result = args[i].call(this,result)
        return result
    }
}
```

现在的compose函数已经可以支持多个函数了,然而有了这个又有什么用呢?

在此之前,我们先了解一个概念叫做pointfree

## pointfree

pointfree指的是函数无需提及将要操作的数据是什么样的。依然是以最初的需求为例:

``` javascript
//需求,输入'xiaobaicai',返回'HELLO XIAOBAICAI'

//非pointfree，因为提到了数据:name
var greet = function(name){
    return ('hello' + name).toUpperCase()
}

//pointfree
//先定义基本运算,这些可以封装起来复用
var toUpperCase = function(x){return x.toUpperCase()}
var hello = function(x){return 'HELLO '+x}

var greet = compose(hello,toUpperCase)
greet('kevin')
```

我们再举一个例子,为了方便书写,我们使用柯里化函数

``` javascript
//需求:输入'xiaobaicai hello haha',返回'X.H.H'

//非pointfree,因为提到了数据:name
var initials = function(name){
    return name.split(' ').map(compose(toUpperCase,head)).join('.')
}

//pointfree
//先定义基本运算
var split = curry(function(separator,str){ return str.split(separator)})
var head = function(str){ return str.slice(0,1)}
var toUpperCase = function(str){ return str.toUpperCase()}
var join = curry(function(separator,arr){ return arr.join(separator)})
var map = curry(function(fn,arr){ return arr.map(fn)})

var initials = compose(join('.'),map(compose(toUpperCase,head)),split(' '))

initials("xiaobaicai hello hi")
```

从这个例子中我们可以看到,利用柯里化(curry)和函数组合(compose)非常有助于实现pointfree

也许你会想,这种写法好麻烦啊.我们还需要定义那么多的基础函数....可是如果有工具库已经帮你写好了呢?比如ramda.js：

``` javascript
//使用ramda.js
var initials = R.compose(R.join('.'),R.map(R.compose(R.toUpper,R.head)),R.split(' '))
```

而且你也会发现：

* pointfree的本质就是使用一些通用的函数,组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。即不使用所要处理的值,只合成运算过程。

那么使用pointfree模式究竟有什么好处呢?

* pointfree模式能够帮助我们减少不必要的命名,让代码保持简洁和通用,更符合语义,更容易复用,测试也变得轻而易举

## 实战

假设我们从服务器获取这样的数据:

``` javascript
var data = {
    result:"SUCCESS",
    tasks:[
        {id:104,  complete:false,             priority:"high",
                  dueDate:"2013-11-29",       username:"Scott"
                  title:"Do something",       created:"9/22/2013"},
        {id: 105, complete: false,            priority: "medium",
                  dueDate: "2013-11-22",      username: "Lena",
                  title: "Do something else", created: "9/22/2013"},
        {id: 107, complete: true,             priority: "high",
                  dueDate: "2013-11-22",      username: "Mike",
                  title: "Fix the foo",       created: "9/22/2013"},
        {id: 108, complete: false,            priority: "low",
                  dueDate: "2013-11-15",      username: "Punam",
                  title: "Adjust the bar",    created: "9/25/2013"},
        {id: 110, complete: false,            priority: "medium",
                  dueDate: "2013-11-15",      username: "Scott",
                  title: "Rename everything", created: "10/2/2013"},
        {id: 112, complete: true,             priority: "high",
                  dueDate: "2013-11-27",      username: "Lena",
                  title: "Alter all quuxes",  created: "10/5/2013"}
    ]
}
```

我们需要写一个名为getIncompleteTaskSummaries的函数,接收一个username作为参数,从服务器获取数据,然后筛选出这个用户的未完成的人物的ids,priorities,titles,和dueDate数据，并且按照日期升序排序。

以Scott为例,最终筛选出的数据为:

``` JavaScript
[
    {id: 110, title: "Rename everything",
        dueDate: "2013-11-15", priority: "medium"},
    {id: 104, title: "Do something",
        dueDate: "2013-11-29", priority: "high"}
]
```

普遍的方式为:

``` javascript
//第一版 过程式编程
var fetchData = function(){
    //模拟
    return Promias.resolve(data)
}

var getIncompleteTaskSummaries = function(memebername){
    return fetchData()
        .then(function(data){
            return data.tasks
        })
        .then(function(tasks){
            return tasks.filter(function(task){
                return task.username == membername
            })
        })
        .then(function(tasks){
            return tasks.filter(function(task){
                return !task.complete
            })
        })
        .then(function(tasks){
            return tasks.map(function(task){
                return {
                    id: task.id,
                    dueDate: task.dueDate,
                    title: task.title,
                    priority:task.priority
                }
            })
        })
        .then(function(tasks){
            return tasks.sort(function(first,second){
                var a = first.dueDate,
                    b = second.dueDate
                return a < b ? -1 : a >b ? 1 : 0
            })
        })
        .then(function(task){
            console.log(task)
        })
}

getIncompleteTaskSummaries('Scott')
```

如果使用pointfree模式:

``` javascript
//第二版pointfree改写
var fetchData = function(){
    return Promise.resolve(data)
}

// 编写基本函数
var prop = curry(function(name, obj) {
    return obj[name];
});

var propEq = curry(function(name, val, obj) {
    return obj[name] === val;
});

var filter = curry(function(fn, arr) {
    return arr.filter(fn)
});

var map = curry(function(fn, arr) {
    return arr.map(fn)
});

var pick = curry(function(args, obj){
    var result = {};
    for (var i = 0; i < args.length; i++) {
        result[args[i]] = obj[args[i]]
    }
    return result;
});

var sortBy = curry(function(fn, arr) {
    return arr.sort(function(a, b){
        var a = fn(a),
            b = fn(b);
        return a < b ? -1 : a > b ? 1 : 0;
    })
});

var getIncompleteTaskSummaries = function(membername) {
    return fetchData()
        .then(prop('tasks'))
        .then(filter(propEq('username', membername)))
        .then(filter(propEq('complete', false)))
        .then(map(pick(['id', 'dueDate', 'title', 'priority'])))
        .then(sortBy(prop('dueDate')))
        .then(console.log)
};

getIncompleteTaskSummaries('Scott')
```

如果直接使用ramda.js，你可以省去编写基本函数

``` javascript
// 第三版 使用 ramda.js
var fetchData = function() {
    return Promise.resolve(data)
};

var getIncompleteTaskSummaries = function(membername) {
    return fetchData()
        .then(R.prop('tasks'))
        .then(R.filter(R.propEq('username', membername)))
        .then(R.filter(R.propEq('complete', false)))
        .then(R.map(R.pick(['id', 'dueDate', 'title', 'priority'])))
        .then(R.sortBy(R.prop('dueDate')))
        .then(console.log)
};

getIncompleteTaskSummaries('Scott')
```

当然了,利用compose,你也可以这样写:

``` javascript
// 第四版 使用 compose
var fetchData = function() {
    return Promise.resolve(data)
};

var getIncompleteTaskSummaries = function(membername) {
    return fetchData()
        .then(R.compose(
            console.log,
            R.sortBy(R.prop('dueDate')),
            R.map(R.pick(['id', 'dueDate', 'title', 'priority'])
            ),
            R.filter(R.propEq('complete', false)),
            R.filter(R.propEq('username', membername)),
            R.prop('tasks'),
        ))
};

getIncompleteTaskSummaries('Scott')
```
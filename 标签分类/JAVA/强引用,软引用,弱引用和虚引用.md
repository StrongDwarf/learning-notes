# 强引用,软引用,弱引用和虚引用

在JDK1.2以前的版本中,当一个对象不被任何变量引用,那么程序就无法再使用这个对象,也就是说,只有对象处于可触及状态,程序才能使用它。
从JDK1.2版本开始,把对象的引用分为四种级别,从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到底依次为:强引用,软引用,弱引用和虚引用。

## 1,强引用

我们使用的大部分引用实际上都是强引用,这是最普遍的引用。如果一个对象具有强引用,那就类似于必不可少的生活用品，垃圾回收期绝不会回收它。当内存空间不足时,Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会随意回收具有强引用的对象来解决内存不足问题

## 2,软引用

当一个对象只具有软引用。如果内存空间足够,垃圾回收期不会回收,如果内存不足,垃圾回收期会回收
软引用可以和一个引用队列联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中

## 3,弱引用

如果一个对象只具有弱引用，当垃圾回收期线程扫描它所管辖的内存区域,不管当前内存空间是否足够，都会回收该对象

## 4,虚引用

虚引用与其他几种引用不同,虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。
虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于:虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收期准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解呗引用的对象是否要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所用的对象的内存被回收之前采取必要的行动。

## 5,用途

在实际开发时，一般很少使用弱引用和虚引用，使用软引用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出等问题的产生。  

例如有些时候,我们使用bitmap后没有保留对它的引用，因此就无法调用Recycle函数。这时巧妙的运用软引用,可以使Bitmap的内存快不足时得到有效的释放。